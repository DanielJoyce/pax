#[cfg(feature = "parser")]
use pax::internal::{PropertyManifestable};
#[cfg(feature = "parser")]
use pax_compiler_api::{ManifestContext, PaxManifest};
#[cfg(feature = "parser")]
use std::collections::{HashSet, HashMap};
#[cfg(feature = "parser")]
use serde_json;



{% if is_root %}
// For the root component only, a `main` is generated for the `parser` bin target.
// This method bootstraps the parsing process, parsing not only the root component
// but every component/primitive found in its extended render tree. This main method
// also returns the parsed, serialized PaxManifest via stdio (println)
#[cfg(feature = "parser")]
pub fn main() {

    let mut ctx = ManifestContext::default();

    let (mut ctx, _) = {{pascal_identifier}}::parse_to_manifest(ctx);

    let manifest = PaxManifest {
        components: ctx.component_definitions,
        root_component_id: ctx.root_component_id,
    };

    //Send data back to parent process by printing to stdout
    println!("{}", &serde_json::to_string_pretty(&manifest).unwrap());
    std::process::exit(0);
}
{% endif %}

{{original_tokens}}

#[cfg(feature = "parser")]
impl {{pascal_identifier}} {
    // For all components, a parse_to_manifest is generated under the `parser` feature
    // so that the parser binary may traverse all dependencies.
    // This method is the recursive workhorse of parsing logic.
    // One way to look at this, in conjunction with the `parser` bin target: a solution to "coordinating between macros"
    pub fn parse_to_manifest(mut ctx: ManifestContext) -> (ManifestContext, String) {

        let source_id = "component::{{pascal_identifier}}";


        {% for property_definition in local_property_definitions %}
        {% for scoped_atomic_type in property_definition.scoped_atomic_types %}

        let property_manifest = {{scoped_atomic_type}}::get_property_manifest("{{property_definition.field_name}}", "{{scoped_atomic_type}}");
        ctx.property_manifests.push(property_manifest);

        //break complex (nested, generic) types into individual calls here, with Tera filters?
        //note: this lacks an awareness of lifetimes
        //TODO: Probably abandon this approach, particularly because of the above
        //      Probably best to enumerate nested properties with awareness of AST, in vanilla macro land


        {% for atomic_type in property_definition.1 | replace(from=">", to="") | split(pat="<") %}
        let property_manifest = {{atomic_type}}::get_property_manifest("{{property_definition.0}}", "{{atomic_type}}");
        ctx.property_manifests.push(property_manifest);
        {% endfor %}


        {% endfor %}



        // TODO: mitigate injection risk here -- notable risk if dealing with untrusted input.  A mitigation may be to sanitize/validate `raw_pax` before templating.

        const raw_pax: &str = r#####"{{raw_pax}}
"#####;
        match ctx.visited_source_ids.get(&source_id as &str) {

            None => {
                //First time visiting this file/source â€” parse the relevant contents
                //then recurse through child nodes, unrolled here in the macro as
                //parsed from the template
                ctx.visited_source_ids.insert(source_id.clone().into());

                {% for dep in dependencies %}
                let (mut ctx, component_id) = {{dep}}::parse_to_manifest(ctx);
                ctx.template_map.insert("{{dep}}".into(), component_id);
                {% endfor %}

                let PASCAL_IDENTIFIER = "{{pascal_identifier}}";

                let template_map= ctx.template_map.clone();

                let (mut ctx, comp_def) =
                    pax_compiler_api::parse_full_component_definition_string(
                        ctx,
                        &raw_pax,
                        PASCAL_IDENTIFIER,
                        {{is_root}},
                        template_map,
                        &source_id,
                        module_path!(),
                    );

                ctx.component_definitions
                    .push(comp_def);

                (ctx, source_id.to_string())
            },
            _ => (ctx, source_id.to_string()), //early return; this file has already been parsed
        }
    }
}