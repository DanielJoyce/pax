use std::borrow::BorrowMut;
use std::cell::RefCell;
use std::collections::HashMap;
use std::ops::Deref;
use std::rc::Rc;
use pax_core::{ComponentInstance, PropertyExpression, RenderNodePtrList, RenderTreeContext, ExpressionContext, PaxEngine, RenderNode, InstanceMap, HandlerRegistry, InstantiationArgs};
use pax_core::pax_properties_coproduct::{PropertiesCoproduct, TypesCoproduct};
use pax_core::repeat::RepeatProperties;

use pax_runtime_api::{ArgsCoproduct, Property, PropertyLiteral, Transform};

//generate dependencies, pointing to userland cartridge (same logic as in PropertiesCoproduct)
use pax_example::pax_types::{RootProperties};
use pax_example::pax_types::pax_std::primitives::{GroupProperties, RectangleProperties};
use pax_example::pax_types::pax_std::types::{Color, StrokeProperties, Size};

//dependency paths below come from pax_primitive macro, where these crate+module paths are passed as parameters:
use pax_std_primitives::{RectangleInstance, GroupInstance };


pub fn instantiate_expression_table() -> HashMap<String, Box<dyn Fn(ExpressionContext) -> TypesCoproduct>> {
    let mut map : HashMap<String, Box<dyn Fn(ExpressionContext) -> TypesCoproduct>> = HashMap::new();

    //literal string IDs to be generated by compiler
    map.insert("a".to_string(), Box::new(|ec: ExpressionContext| -> TypesCoproduct {
        //note that type coercion should happen here, too:
        //(must know symbol name as well as source & destination types)
        //(compiler can keep a dict of operand types)

        //for @frames_elapsed
        #[allow(non_snake_case)]
        let __AT__frames_elapsed = ec.engine.frames_elapsed as f64;
        TypesCoproduct::Transform(
            Transform::origin(Size::Percent(50.0), Size::Percent(50.0)) *
            Transform::scale(2.3, 2.3) *
            Transform::rotate( __AT__frames_elapsed / 270.0) *
            Transform::origin(Size::Percent(f64::sin(__AT__frames_elapsed / 1000.0) * 100.0), Size::Percent(f64::cos(__AT__frames_elapsed / 1000.0) * 100.0)) *
            Transform::rotate((f64::cos(__AT__frames_elapsed / 100.0) * 0.010 + 1.0) * (__AT__frames_elapsed) / 37.0) *
            Transform::align(0.5, 0.5)
        )
    }));

    map.insert("b".to_string(), Box::new(|ec: ExpressionContext| -> TypesCoproduct {
        #[allow(non_snake_case)]
        let self__DOT__current_rotation = if let PropertiesCoproduct::Root(p) = &*(*ec.stack_frame).borrow().get_scope().borrow().properties.borrow() {
            *p.current_rotation.get()
        } else { unreachable!() };

        TypesCoproduct::Transform(
            Transform::align(0.5, 0.5) *
            Transform::rotate(self__DOT__current_rotation)
        )
    }));


    map.insert("c".to_string(), Box::new(|ec: ExpressionContext| -> TypesCoproduct {
        #[allow(non_snake_case)]
            let __AT__frames_elapsed = ec.engine.frames_elapsed as f64;
        #[allow(non_snake_case)]
            let self__DOT__rotation = if let PropertiesCoproduct::Root(p) = &*(*ec.stack_frame).borrow().get_scope().borrow().properties.borrow() {
            *p.current_rotation.get()
        } else { unreachable!() };

        //TODO: how to determine that StrokeProperties is compound and requires
        //      wrapping in PropertyLiteral values?
        TypesCoproduct::Stroke(
            StrokeProperties {
                color: Box::new(PropertyLiteral (Color::hlca((__AT__frames_elapsed as isize % 360) as f64, 100.0,100.0,1.0) )),
                width: Box::new(PropertyLiteral (45.0)),
            }
        )
    }));

    map
}

pub fn instantiate_root_component(instance_map: Rc<RefCell<InstanceMap>>) -> Rc<RefCell<ComponentInstance>> {
    ComponentInstance::instantiate(
        InstantiationArgs{
            properties: PropertiesCoproduct::Root(RootProperties {
                num_clicks: Box::new(PropertyLiteral(0) ),
                current_rotation: Box::new(PropertyLiteral(0.0)),
                deeper_struct: Default::default(),
            }),
            handler_registry: None,
            instance_map: Rc::clone(&instance_map),
            transform: Transform::default_wrapped(),
            size: None,
            children: Some(Rc::new(RefCell::new(vec![
                GroupInstance::instantiate(InstantiationArgs {
                    properties: PropertiesCoproduct::Empty,
                    handler_registry: None,
                    instance_map: Rc::clone(&instance_map),
                    transform: Transform::default_wrapped(),
                    size: None,
                    adoptees: None,
                    compute_properties_fn: None,
                    children: Some(Rc::new(RefCell::new(vec![
                        RectangleInstance::instantiate(InstantiationArgs {
                            properties: PropertiesCoproduct::Rectangle(RectangleProperties{
                                stroke: Box::new(PropertyExpression {id: "c".into(), cached_value: Default::default()}),
                                fill: Box::new(PropertyLiteral (Color::rgba(1.0, 1.0, 0.0, 1.0)))
                            }),
                            handler_registry: None,
                            instance_map: Rc::clone(&instance_map),
                            transform: Transform::default_wrapped(),
                            size: Some([PropertyLiteral(Size::Pixel(200.0)).into(),PropertyLiteral(Size::Pixel(200.0)).into()]),
                            children: None,
                            adoptees: None,
                            compute_properties_fn: None
                        })
                    ]))),
                })
            ]))),
            adoptees: None,
            compute_properties_fn: Some(Box::new(|properties, rtc|{
                let mut properties = &mut *properties.as_ref().borrow_mut();
                let mut root_properties = if let PropertiesCoproduct::Root(p) = properties {p} else {unreachable!()};
                root_properties.current_rotation._get_vtable_id();
                //
                //
                // let maybe_id = { properties.stroke._get_vtable_id().clone() };
                // if let Some(id) = maybe_id {
                //     if let Some(evaluator) = rtc.engine.expression_table.get(id) {
                //         let ec = ExpressionContext {
                //             engine: rtc.engine,
                //             stack_frame: Rc::clone(&(*rtc.runtime).borrow_mut().peek_stack_frame().unwrap())
                //         };
                //         let new_value = (**evaluator)(ec);
                //         if let TypesCoproduct::Stroke(cast_new_value) = new_value {
                //             properties.stroke.set(cast_new_value)
                //         }
                //     }
                // }

                //
                //
                // let mut properties_unwrapped = &*(*properties).borrow_mut();
                // if let PropertiesCoproduct::Root(properties_cast) =  &mut properties_unwrapped {
                //     rtc.compute_property(properties_cast.current_rotation._get_vtable_id(), Box::new(|new_value: TypesCoproduct|{
                //         let cast = if let TypesCoproduct::f64(p) = new_value {p} else {unreachable!()};
                //         properties_cast.borrow_mut().current_rotation.set(cast);
                //     }));

                    //
                    // let mut properties = &mut *self.properties.as_ref().borrow_mut();
                    // let maybe_id = { properties.stroke._get_vtable_id().clone() };
                    // if let Some(id) = maybe_id {
                    //     if let Some(evaluator) = rtc.engine.expression_table.borrow().get(id) {
                    //         let ec = ExpressionContext {
                    //             engine: rtc.engine,
                    //             stack_frame: Rc::clone(&(*rtc.runtime).borrow_mut().peek_stack_frame().unwrap())
                    //         };
                    //         let new_value = (**evaluator)(ec);
                    //         if let TypesCoproduct::Stroke(cast_new_value) = new_value {
                    //             properties.stroke.set(cast_new_value)
                    //         }
                    //     }
                    // }
                // } else {unreachable!()}






            }))
        }
    )
}

//Root => get_instance()


//Rectangle => get_instance()
//Group => get_instance()