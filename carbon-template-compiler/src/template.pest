/*
This grammar describes a `template`:
an XML-like document with support for @{}-style templating (embedding expressions)
*/

WHITESPACE = _{ " " | "\t" | "\r" | NEWLINE }
COMMENT = _{ ( "/*" ~ (!"*/" ~ ANY)* ~ "*/" ) | ("//" ~ (!NEWLINE ~ ANY) ~ NEWLINE) }

//A template has exactly one root tag
template = { SOI ~ any_tag ~ properties_declaration? ~ EOI }

//On the other hand, a sub_template (e.g. the child-contents of an element)
//may have multiple top-level siblings
sub_template = { any_tag* }

open_tag = {"<" ~ PUSH(pascal_identifier) ~ attribute_key_value_pair* ~ ">"}
closing_tag = {"</" ~ POP ~ ">"}

attribute_key_value_pair = _{identifier ~ "=" ~ any_template_value}
any_template_value = {string | expression}
any_tag = _{matched_tag | self_closing_tag}

matched_tag = {open_tag ~ sub_template ~ closing_tag}
self_closing_tag = {"<" ~ pascal_identifier ~ attribute_key_value_pair* ~ "/>"}

string = ${ ("\"" ~ inner ~ "\"") | ("'" ~ inner ~ "'") }
inner = @{ char* }
char = {
    !("\"" | "\\") ~ ANY
    | "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
    | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
}

identifier = { (ASCII_ALPHANUMERIC | "_" | "-")+ }
pascal_identifier = @{ ASCII_ALPHA_UPPER ~ (ASCII_ALPHANUMERIC | "_" | "-")*}

properties_declaration = {"@properties" ~ "{" ~ selector_block* ~ "}"}
selector_block = {selector ~ properties_block}
properties_block = { "{" ~ properties_key_value_pair* ~ "}" }

//Note: only id and class selector supported for now; could be extended
selector = @{("." | "#") ~ identifier}

properties_key_value_pair = {properties_key ~ properties_value ~ ","?}
properties_key = @{identifier ~ ":"}
properties_value = {literal_value | enum_value | expression | properties_block}
literal_value = {literal_number_with_unit | literal_number | literal_array | string}
literal_number_with_unit = @{literal_number ~ literal_number_unit}
literal_number = {literal_number_float | literal_number_integer}
literal_number_integer = {(!(".") ~ ASCII_DIGIT)+ }
literal_number_float = {ASCII_DIGIT* ~ "." ~ ASCII_DIGIT+}
literal_number_unit = {("%" | "px")}
literal_array = {("[") ~ literal_value ~ ("," ~ literal_value)* ~ ("]")}
enum_value = @{pascal_identifier ~ ("::" ~ pascal_identifier ~ ("("~enum_args_list~")")?)?}
enum_args_list = !{properties_value ~ ("," ~ properties_value)*}


//Expressions can be:
// a.) symbolic bindings to properties, e.g. `@num_clicks`
// b.) lambdas, where types will be enforced by semantizer
// c.) control-flow statements: if/repeat/placeholder
expression = @{
    "@" ~ (expression_symbolic_binding | expression_lambda | expression_control_flow)
}

expression_symbolic_binding = {identifier ~ ("." ~ identifier)*}
expression_lambda = !{"{"~expression_body~"}"}
expression_body = {"EXP_TODO"} //TODO: figure out how to make this more robust... might need to include the expression grammar itself for {}-matching, or may be able to hack a combo of look-ahead and PUSH/POP for {}
expression_control_flow = {statement_if | statement_foreach | statement_placeholder}

statement_if = {"if" ~ "(" ~ expression_body ~ ")" ~ "{" ~ sub_template ~ "}"} //TODO: else
statement_foreach = {"foreach" ~ "(" ~ expression_body ~ ")" ~ "{" ~ sub_template ~ "}"}
statement_placeholder = {"placeholder"}

